<!DOCTYPE html><html lang="en" data-critters-container><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="https://img.picgo.net/2024/11/27/IMG_2742a0295d98a1ea79ee.jpeg"><script>!function(){const e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("vueuse-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script><style type="text/css">:root{color-scheme:light dark;--va-c-bg:#fff}html.dark{--va-c-bg:#000}html{background-color:var(--va-c-bg)}</style><script>const locale=localStorage.getItem("valaxy-locale")||"zh-CN";document.documentElement.setAttribute("lang",locale)</script><script type="module" async crossorigin src="/xx-blog/assets/app-CLGX1n_q.js"></script><link rel="stylesheet" crossorigin href="/xx-blog/assets/app-CGM_433a.css"><link rel="modulepreload" crossorigin href="/xx-blog/assets/post-CPfdgEYd.js"><link rel="stylesheet" href="/xx-blog/assets/post-DDxwAI70.css"><link rel="modulepreload" crossorigin href="/xx-blog/assets/vue-1-CJ0hOOwB.js"><title>vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进 - 欣的代码驿站</title><meta property="og:locale:alternate" content="en"><meta property="og:description" content><meta property="og:locale" content="zh-CN"><meta property="og:site_name" content="欣的代码驿站"><meta property="og:title" content="vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进"><meta property="og:image" content="https://img.picgo.net/2024/11/27/IMG_2742a0295d98a1ea79ee.jpeg"><meta property="og:type" content="website"><meta property="og:url" content="https://nightsquirrl.github.io/xx-blog/"><link rel="icon" href="https://img.picgo.net/2024/11/27/IMG_2742a0295d98a1ea79ee.jpeg" type="image/png"><meta name="description" content><meta name="generator" content="Valaxy 0.20.4"><script id="check-mac-os" async>document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap"><meta name="theme-color" content="#fff"><meta name="msapplication-TileColor" content="#fff"></head><body><div id="app" data-server-rendered="true"><!--[--><!--[--><!----><!----><div class="yun-page-header-gradient" style="--gradient-from:161 196 253;--gradient-to:194 233 251"></div><!----><!----><!----><canvas class="fireworks"></canvas><!--[--><div class="yun-bg"></div><!--]--><div class="yun-page-loading" absolute left-0 right-0 bottom-0 top-0 flex justify="center" items-center z-10 bg="$va-c-bg" data-v-673bc094><div class="spinner" data-v-673bc094></div></div><a href="#" class="back-to-top yun-icon-btn bg-$va-c-bg-soft shadow-md"><div class="size-8" i-ri-arrow-up-s-line></div><svg class="progress-circle-container" viewBox="0 0 100 100"><circle stroke-dasharray="301.59289474462014 301.59289474462014" stroke-dashoffset="301.59289474462014" stroke="currentColor" stroke-width="2" stroke-linecap="round" class="progress-circle" cx="50" cy="50" r="48" fill="none"/></svg></a><!-- TODO --><!-- <YunDock /> --><!--]--><!--[--><!--]--><!----><!--[--><div flex="~" class="w-full m-auto justify-center items-start gap-4 mt-24 md:mt-36"><!--[--><!----><main class="yun-main lt-md:w-full" flex="~ center"><!--[--><div class="content w-full md:w-3xl lg:w-2xl xl:w-2xl 2xl:w-4xl" flex="~ col grow" p="lt-md:0"><div class="yun-card flex-center rounded relative" flex="col" min-h="100px" bg="$va-c-bg-light" m="0" style><!----><!----><!--[--><div class="mt-8 mb-4"><!--[--><header class="post-header"><h1 p="2" text="2xl center" font="serif black" style="" class="post-title flex-center"><!----><span inline-flex class="leading-none">vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进</span></h1></header><!--]--></div><!--[--><!--[--><!--[--><!----><!----><div class="post-top-icon" color="$va-c-warning"><div i-ri-pushpin-line></div></div><div flex="~ center" text="sm" class="flex-col gap-2! post-meta gap-4"><div class="post-time flex items-center gap-4"><span class="posted-time inline-flex-center gap-1" title="发表于2024-12-10 00:00:00"><div class="inline-block" i-ri-calendar-line></div><time class="op-80">2024-12-10</time></span><!----></div><div class="inline-flex-center gap-4"><!----><!----></div></div><!--]--><div class="inline-flex mt-2" text="sm" py="1"><a href="/xx-blog/categories?category=vue+%E9%9D%A2%E8%AF%95" class="transition post-category inline-flex-center text-xs border-$va-c-divider" px-2 h="7" border rounded-full hover="bg-blue-500 text-white"><div m="x-1" inline-flex i-ri-folder-2-line></div><span>vue 面试</span></a><span mx="2"></span><div class="post-tags inline-flex" items="center" gap="1" flex="wrap 1" justify="end"><!--[--><a href="/xx-blog/tags/?tag=vue" class="transition post-tag inline-flex-center text-xs border-$va-c-divider" px-2 h="7" rounded-full border hover="bg-blue-500 text-white"><span>vue</span></a><a href="/xx-blog/tags/?tag=%E9%9D%A2%E8%AF%95" class="transition post-tag inline-flex-center text-xs border-$va-c-divider" px-2 h="7" rounded-full border hover="bg-blue-500 text-white"><span>面试</span></a><!--]--></div></div><!--]--><!--]--><div p="x-4 b-8" class="sm:px-6 lg:px-12 xl:px-16" w="full"><!--[--><!-- <Transition appear> --><article class="markdown-body"><!--[--><!----><!----><!--[--><h3 id="简单描述" tabindex="-1">简单描述 <a class="header-anchor" href="#简单描述" aria-label="Permalink to &quot;简单描述&quot;">​</a></h3><p>性能更好，解决无法监听数组变化问题</p><h3 id="略微详细" tabindex="-1">略微详细 <a class="header-anchor" href="#略微详细" aria-label="Permalink to &quot;略微详细&quot;">​</a></h3><ul><li>Vue2.x通过给每个对象添加getter setter属性去改变对象,实现对数据的观测,Vue3.x通过Proxy代理目标对象,且一开始只代理最外层对象,嵌套对象lazy by default ,性能会更好</li><li>支持数组索引修改,对象属性的增加,删除</li></ul><h3 id="详细版本" tabindex="-1">详细版本 <a class="header-anchor" href="#详细版本" aria-label="Permalink to &quot;详细版本&quot;">​</a></h3><p>在Vue 3.0 中使用 Proxy 主要是为了实现响应式数据的变化检测和触发。相比于 Vue 2.x 中使用的 Object.defineProperty，Proxy 提供了更强大和灵活的功能，以及更好的性能表现。</p><p>以下是 Proxy 相比 Object.defineProperty 的一些改进和优势：</p><ol><li><p>更强大和灵活：Proxy 可以代理整个对象，而不仅仅是对象的属性。这意味着您可以监听对象的整个操作，包括属性的增删改查等。而 Object.defineProperty 只能监听对象的属性的读取和赋值操作。</p></li><li><p>更直观和易用：使用 Proxy 可以更直观地监听对象的操作，而不需要像 Object.defineProperty 那样手动定义 getter 和 setter。这使得代码更加清晰和易于理解。</p></li><li><p>更好的性能：Proxy 的性能通常比 Object.defineProperty 更好，因为 Proxy 是原生实现的，而 Object.defineProperty 是 JavaScript 引擎的内部实现。Proxy 的底层实现更高效，可以更好地处理大型对象和多次操作。</p></li><li><p>支持数组变化的检测：使用 Proxy 可以很容易地监听数组的变化，包括数组的 push、pop、splice 等操作。而 Object.defineProperty 难以实现对数组变化的监听。</p></li></ol><h4 id="object-defineproerty" tabindex="-1"><code>Object.defineProerty</code> <a class="header-anchor" href="#object-defineproerty" aria-label="Permalink to &quot;`Object.defineProerty`&quot;">​</a></h4><p>Object.defineProperty是ES5的属性</p><blockquote><p>Object.defineProperty(object, property, descriptor)</p></blockquote><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p><h5 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h5><p>object: 要定义属性的对象 property: 要定义或修改的属性的名称或 Symbol descriptor: 要定义或修改的属性描述符</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code v-pre><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">descriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: 默认为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  writable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: 默认为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  enumerable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: 默认为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // 当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  configurable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: 默认为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // 当且仅当该属性的 configurable 键值为 true 时，该属性才可以被删除，以及除 value 和 writable 特性外的其他特性才能可以被修改</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: 默认为</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // 属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。该函数的返回值就是属性的值。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: 默认为</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // 属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre><button class="collapse"></button></div><h4 id="proxy" tabindex="-1"><code>Proxy</code> <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;`Proxy`&quot;">​</a></h4><h5 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h5><p><code>Proxy</code> 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<code>Proxy</code> 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code v-pre><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> proxy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(target, handler);</span></span></code></pre><button class="collapse"></button></div><h5 id="参数-1" tabindex="-1">参数 <a class="header-anchor" href="#参数-1" aria-label="Permalink to &quot;参数&quot;">​</a></h5><p><code>target</code> 参数表示所要代理的目标对象，<code>handler</code> 参数也是一个对象，用来定制代理拦截行为。 <code>Proxy</code> 对象的所有用法，都是上面这种形式，不同的只是 <code>handler</code> 参数的写法。其中，<code>new Proxy()</code> 表示生成一个<code>Proxy</code>实例。</p><h6 id="handler解析" tabindex="-1">handler解析 <a class="header-anchor" href="#handler解析" aria-label="Permalink to &quot;handler解析&quot;">​</a></h6><p>关于handler拦截属性，有如下：</p><ul><li><code>get(target,propKey,receiver)</code>：拦截对象属性的读取</li><li><code>set(target,propKey,value,receiver)</code>：拦截对象属性的设置</li><li><code>has(target,propKey)</code>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值</li><li><code>deleteProperty(target,propKey)</code>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li><li><code>ownKeys(target)</code>：拦截<code>Object.keys(proxy)、for...in</code>等循环，返回一个数组</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象</li><li><code>defineProperty(target, propKey, propDesc)</code>：拦截<code>Object.defineProperty(proxy, propKey, propDesc</code>），返回一个布尔值</li><li><code>preventExtensions(target)</code>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值</li><li><code>getPrototypeOf(target)</code>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</li><li><code>isExtensible(target)</code>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</li><li><code>setPrototypeOf(target, proto)</code>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值</li><li><code>apply(target, object, args)</code>：拦截 <code>Proxy</code> 实例作为函数调用的操作</li><li><code>construct(target, args)</code>：拦截 <code>Proxy</code> 实例作为构造函数调用的操作</li></ul><h5 id="🌰" tabindex="-1">🌰 <a class="header-anchor" href="#🌰" aria-label="Permalink to &quot;🌰&quot;">​</a></h5><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code v-pre><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> proxy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">   },{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // target 是要代理的对象，key 是要获取的属性</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // 原对象的属性名称在代理之后是不会发生变化的</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 35</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(proxy.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// 35</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(proxy.age);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// 35</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(proxy.time); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// 35</span></span></code></pre><button class="collapse"></button></div><h4 id="reflect" tabindex="-1">Reflect <a class="header-anchor" href="#reflect" aria-label="Permalink to &quot;Reflect&quot;">​</a></h4><p>若需要在Proxy内部调用对象的默认行为，建议使用Reflect，其是ES6中操作对象而提供的新 API</p><p>基本特点：</p><p>只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在 修改某些Object方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回false） 让Object操作都变成函数行为.</p><p>阅读 Proxy 的 MDN 文档上可能会发现其实 Proxy 中 get 陷阱中还会存在一个额外的参数 receiver 。 通过我们上述对 window.Reflect 的打印可以看到，Reflect 的方法、属性和 Proxy 是一样的，所以 Reflect get 也是有这 第三个 receiver 属性的；这个receiver是触发代理对象的劫持时保证正确的 this 上下文指向，它正是可以修改属性访问中的 this 指向为传入的 receiver 对象。也是为了框架健壮性。使用 Object.defineProperty() 重复声明的属性会报错，因为 JavaScript 是单线程语言，一旦抛出异常，后边的任何逻辑都不会执行，所以为了避免这种情况，我们在底层就要写 大量的 try catch 来避免，不够优雅。 但是使用 Reflect.defineProperty() 是有返回值的，所以通过 返回值 来判断你当前操作是否成功。</p><h3 id="解决vue2-object-defineproperty的难题" tabindex="-1">解决vue2 Object.defineProperty的难题 <a class="header-anchor" href="#解决vue2-object-defineproperty的难题" aria-label="Permalink to &quot;解决vue2 Object.defineProperty的难题&quot;">​</a></h3><ol><li>一次只能对一个属性进行监听，需要遍历来对所有属性监听。这个我们在上面已经讲过了。</li><li>在遇到一个对象的属性还是一个对象的情况下，需要递归监听。</li><li>对于对象的新增属性，需要手动监听</li><li>对于数组通过push、unshift方法增加的元素，也无法监听 但是看过vue3源码的同学可以发现，vue3的响应式并不是只用了proxy来实现的，还用了一个搭档Reflect。也就是Proxy(代理) 配合 Reflect(反射) 进行设计的。那么就有疑问了 为什么要用上Reflect。</li></ol><!--]--><!--[--><!--]--><!--]--><!----><!----></article><!-- </Transition> --><!--]--><!--[--><!--[--><!--v-if--><ul class="post-copyright" m="y-4"><li class="post-copyright-author"><strong>本文作者：</strong><span>欣欣子</span></li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://nightsquirrl.github.io/xx-blog/posts/vue/vue-1" target="_blank" title="本文链接">https://nightsquirrl.github.io/xx-blog/posts/vue/vue-1</a></li><li class="post-copyright-license"><strong>版权声明：</strong><span>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 ">CC BY-NC-SA</a> 许可协议。</span></li></ul><!--]--><!--]--></div><!--]--><!----></div><!--[--><!--]--><!--[--><div class="post-nav"><div class="post-nav-item"><a href="/xx-blog/posts/project-init/vue/path-alias" class="post-nav-prev" title="路径别名"><div class="icon" i-ri-arrow-left-s-line></div><span class="title truncate" text="sm">路径别名</span></a></div><div class="post-nav-item"><!----></div></div><!--]--><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div><!--]--></main><!--[--><button class="xl:hidden toc-btn shadow-md fixed yun-icon-btn z-350 bg-$va-c-bg-soft" opacity="75" right="2" bottom="19"><div i-ri-file-list-line></div></button><!----><aside flex="~ col" class="va-card yun-aside sticky top-0 lg:top-$yun-margin-top min-h-sm" text="center" overflow="auto"><div style="display:none" class="w-full" flex="~ col" pb-2><!--[--><h2 m="t-6 b-2" font="serif black">文章目录</h2><div style="display:none" data-v-233b73a6><div class="content" data-v-233b73a6><div class="outline-title" data-v-233b73a6>On this page</div><div class="outline-marker" data-v-233b73a6></div><nav aria-labelledby="doc-outline-aria-label" data-v-233b73a6><span id="doc-outline-aria-label" class="visually-hidden" data-v-233b73a6>Table of Contents for current page</span><ul class="root va-toc relative z-1 css-i18n-toc" data-v-233b73a6 data-v-699db71a><!--[--><!--]--></ul></nav></div></div><!--]--><div class="flex-grow"></div><!----></div></aside><!--]--><!--]--></div><footer flex="~ col" class="relative yun-footer va-footer px-4 py-4 pt-0 text-$va-c-text-light w-full mt-14" bg="white dark:$va-c-bg-soft" text="center sm"><div class="yun-cloud absolute top--10 left-0 right-0"><svg class="waves" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" fill="var(--yun-c-cloud)"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><!----><div class="copyright flex justify-center items-center gap-2" p="1"><span>©<!----> 2024</span><a class="animate-pulse inline-flex" href="https://sponsors.yunyoujun.cn" target="_blank" title="Sponsor YunYouJun"><div class="i-ri-cloud-line"></div></a><span>欣欣子</span></div><!----><!--[--><!--]--><div class="yun-footer-gradient" style="--gradient-from:161 196 253;--gradient-to:194 233 251"></div></footer><!--]--><!--]--></div><script>window.__INITIAL_STATE__='{"pinia":{"yun-app":{},"app":{"isMobile":false,"showLoading":true},"site":{},"routerStore":{}}}'</script><script type="application/ld+json" data-hid="3437552">{"@context":"https://schema.org","@graph":[{"@id":"https://nightsquirrl.github.io/xx-blog/#identity","@type":"Person","name":"欣欣子","url":"https://nightsquirrl.github.io/xx-blog/","image":{"@id":"https://nightsquirrl.github.io/xx-blog/#/schema/image/25c4d81"},"sameAs":["https://github.com/","https://music.163.com/"]},{"@id":"https://nightsquirrl.github.io/xx-blog/#website","@type":"WebSite","dateModified":"2024-11-29","datePublished":"2024-11-29","inLanguage":"zh-CN","name":"unplugin-vue-components组件自动按需引入","url":"https://nightsquirrl.github.io/xx-blog/","publisher":{"@id":"https://nightsquirrl.github.io/xx-blog/#identity"}},{"@id":"https://nightsquirrl.github.io/xx-blog/#webpage","@type":"WebPage","dateModified":"2024-11-29T00:00:00.000Z","datePublished":"2024-11-29T00:00:00.000Z","description":true,"name":"vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进","url":"https://nightsquirrl.github.io/xx-blog/","about":{"@id":"https://nightsquirrl.github.io/xx-blog/#identity"},"isPartOf":{"@id":"https://nightsquirrl.github.io/xx-blog/#website"},"potentialAction":[{"@type":"ReadAction","target":["https://nightsquirrl.github.io/xx-blog/"]}]},{"@id":"https://nightsquirrl.github.io/xx-blog/#article","dateModified":"2024-11-29T00:00:00.000Z","datePublished":"2024-11-29T00:00:00.000Z","description":true,"headline":"unplugin-vue-components组件自动按需引入","inLanguage":"zh-CN","thumbnailUrl":"https://img.picgo.net/2024/11/27/IMG_2742a0295d98a1ea79ee.jpeg","@type":["Article","BlogPosting"],"author":{"@id":"https://nightsquirrl.github.io/xx-blog/#/schema/person/a3b96ce"},"image":{"@id":"https://nightsquirrl.github.io/xx-blog/#/schema/image/25c4d81"},"isPartOf":{"@id":"https://nightsquirrl.github.io/xx-blog/#webpage"},"mainEntityOfPage":{"@id":"https://nightsquirrl.github.io/xx-blog/#webpage"},"publisher":{"@id":"https://nightsquirrl.github.io/xx-blog/#identity"}},{"@id":"https://nightsquirrl.github.io/xx-blog/#/schema/person/a3b96ce","@type":"Person","name":"欣欣子","url":"xxxxx"},{"@id":"https://nightsquirrl.github.io/xx-blog/#/schema/image/25c4d81","@type":"ImageObject","contentUrl":"https://img.picgo.net/2024/11/27/IMG_2742a0295d98a1ea79ee.jpeg","inLanguage":"zh-CN","url":"https://img.picgo.net/2024/11/27/IMG_2742a0295d98a1ea79ee.jpeg"}]}</script></body></html>